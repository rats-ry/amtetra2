#!/usr/bin/env python3
"""Some "manual" tests for L2 coding functions"""

import time
import cProfile

import numpy as np

import debug
import l2_coding as coding
import pdu_class as pdu

def bytes_to_np(b):
    """Convert from old representation of bits (bytes object) into the new representation (numpy array).
    This is mainly used for testing before all of the code is converted to use numpy arrays."""
    return np.frombuffer(b, dtype=np.uint8)

# Bits demodulated from DMO synchronization bursts
burst_strs = [
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 11 11 11 11 00 01 10 11 11 10 11 01 01 10 10 01 01 00 00 00 01 11 11 10 10 11 11 10 10 11 11 11 10 10 11 10 11 11 10 11 11 01 10 00 10 11 11 00 00 11 11 01 00 10 10 00 11 10 10 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 01 11 11 11 00 01 10 11 11 10 11 01 01 10 11 01 01 00 00 00 10 11 01 10 10 10 01 11 10 11 10 11 10 10 11 10 11 11 10 11 11 00 00 00 10 11 11 11 00 11 11 01 01 00 11 00 11 10 01 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 01 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 11 11 11 11 10 00 10 11 11 00 11 01 01 10 11 11 00 00 00 01 10 11 01 10 10 01 11 10 10 11 11 01 10 10 11 10 00 11 10 11 11 00 00 01 10 11 11 11 00 01 11 01 00 00 11 00 11 10 10 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 01 11 11 11 10 00 10 11 11 00 11 01 01 10 10 11 00 00 00 01 01 11 11 10 10 00 01 11 10 11 10 01 10 10 11 10 00 11 10 11 11 01 10 01 10 11 11 00 00 01 11 01 01 10 10 00 11 10 01 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 01 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 10 10 11 11 11 10 01 00 11 11 01 11 00 01 10 11 11 01 00 00 01 10 11 11 10 10 00 01 11 10 11 10 00 10 10 11 10 10 11 11 11 11 00 10 00 00 11 11 01 00 11 11 01 00 11 10 00 11 10 11 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 00 01 11 11 01 10 00 10 11 11 01 10 10 10 10 00 11 01 01 00 10 00 01 01 11 00 11 10 10 10 11 01 10 00 10 11 00 10 11 10 10 01 11 00 00 00 11 01 10 00 01 10 11 00 10 00 00 01 11 00 00 00 01 11 11 01 01 01 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 10 10 00 10 01 01 01 10 10 10 01 00 10 10 01 10 10 10 00 10 11 01 10 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 10 00 11 11 11 10 01 00 11 11 01 11 00 01 10 10 11 01 00 00 01 01 11 01 10 10 01 11 10 10 11 11 00 10 10 11 10 10 11 11 11 11 01 00 00 00 11 11 10 00 11 11 01 01 01 11 00 11 10 00 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 00 01 11 11 01 10 00 10 11 11 01 10 10 10 10 00 11 01 01 00 10 00 01 01 11 00 11 10 10 10 11 01 10 00 10 11 00 10 11 10 10 01 11 00 00 00 11 01 10 00 01 10 11 00 10 00 00 01 11 00 00 00 01 11 11 01 01 01 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 10 10 00 10 01 01 01 10 10 10 01 00 10 10 01 10 10 10 00 10 11 01 10 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 10 10 11 11 11 00 00 00 11 11 11 11 00 01 10 10 01 00 00 00 00 01 11 01 10 10 10 01 11 10 11 10 10 10 10 11 10 01 11 11 11 11 01 00 01 00 11 11 10 00 01 11 01 00 01 11 00 11 10 11 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 00 01 11 11 01 10 00 10 11 11 01 10 10 10 10 00 11 01 01 00 10 00 01 01 11 00 11 10 10 10 11 01 10 00 10 11 00 10 11 10 10 01 11 00 00 00 11 01 10 00 01 10 11 00 10 00 00 01 11 00 00 00 01 11 11 01 01 01 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 10 10 00 10 01 01 01 10 10 10 01 00 10 10 01 10 10 10 00 10 11 01 10 10 00"
]

punct_2_3 = coding.generate_puncturing_pattern(120, (2,3))
deint_11 = coding.generate_deinterleaving_pattern(K = 120, a = 11)

for burst_str in burst_strs:

    # Handle the burst as a byte array, each byte representing one bit
    burst = bytes(1 if c=="1" else 0 for c in burst_str.replace(" ", ""))
    burst = bytes_to_np(burst)

    # Split into fields
    sb_bits5 = burst[94:214]  # Scrambled synchronization block 1 type 5 bits
    bkn2_bits5 = burst[252:468]  # Scrambled block 2 bits

    debug.print_bits("Type 5:", sb_bits5)

    # Convert to type 4 bits
    sb_bits4 = coding.descramble(sb_bits5, coding.sb_scrambling)

    debug.print_bits("Type 4:", sb_bits4)

    # Convert to type 3 bits
    sb_bits3 = coding.deinterleave(sb_bits4, deint_11)

    debug.print_bits("Type 3:", sb_bits3)

    sb_depunct = coding.depuncture(coding.hard_to_soft(sb_bits3), punct_2_3)
    debug.print_softbits("Depunctured:", sb_depunct)
    sb_bits2 = coding.decode_1_4(sb_depunct)
    debug.print_bits("Type 2:", sb_bits2)

    sb_bits1 = sb_bits2[0:-16]
    debug.print_bits("Type 1 (not CRC checked):", sb_bits1)
    debug.print_bits("Received   CRC:", sb_bits2[-16:])
    debug.print_bits("Calculated CRC:", coding.crc16(sb_bits1))

    # Show some DMAC-SYNC PDU contents in SCH/S
    debug.print_pdu(pdu.DMAC_SYNC_SCH_S(sb_bits1))

# Speedtest
N = 10000

def test_things():
    sb_bits5 = burst[94:214]
    sb_bits4 = coding.descramble(sb_bits5, coding.sb_scrambling)
    sb_bits3 = coding.deinterleave(sb_bits4, deint_11)
    sb_depunct = coding.depuncture(coding.hard_to_soft(sb_bits3), punct_2_3)
    sb_bits2 = coding.decode_1_4(sb_depunct)
    crc = coding.crc16(sb_bits2[0:-16])
    sb_bits1 = sb_bits2[0:-16]
    return pdu.DMAC_SYNC_SCH_S(sb_bits1)


t1 = time.perf_counter()
#for i in range(N):
#    test_things()
cProfile.run("for i in range(N): test_things()")
t2 = time.perf_counter()
print("Descrambled, deinterleaved, decoded and unpacked %f blocks per second" % (N / (t2-t1)))
