#!/usr/bin/env python3

# Some "manual" tests for L2 coding functions

import l2_coding as coding, debug
import numpy as np

def bytes_to_np(b):
    """Convert from old representation of bits (bytes object) into the new representation (numpy array).
    This is mainly used for testing before all of the code is converted to use numpy arrays."""
    return np.frombuffer(b, dtype=np.uint8)

# Bits demodulated from DMO synchronization bursts
burst_strs = [
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 11 11 11 11 00 01 10 11 11 10 11 01 01 10 10 01 01 00 00 00 01 11 11 10 10 11 11 10 10 11 11 11 10 10 11 10 11 11 10 11 11 01 10 00 10 11 11 00 00 11 11 01 00 10 10 00 11 10 10 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 01 11 11 11 00 01 10 11 11 10 11 01 01 10 11 01 01 00 00 00 10 11 01 10 10 10 01 11 10 11 10 11 10 10 11 10 11 11 10 11 11 00 00 00 10 11 11 11 00 11 11 01 01 00 11 00 11 10 01 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 01 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 11 11 11 11 10 00 10 11 11 00 11 01 01 10 11 11 00 00 00 01 10 11 01 10 10 01 11 10 10 11 11 01 10 10 11 10 00 11 10 11 11 00 00 01 10 11 11 11 00 01 11 01 00 00 11 00 11 10 10 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 00 01 11 11 11 10 00 10 11 11 00 11 01 01 10 10 11 00 00 00 01 01 11 11 10 10 00 01 11 10 11 10 01 10 10 11 10 00 11 10 11 11 01 10 01 10 11 11 00 00 01 11 01 01 10 10 00 11 10 01 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 10 01 11 11 01 11 00 00 11 11 01 10 11 10 00 00 11 11 01 01 10 10 01 01 11 00 10 10 00 10 11 11 10 01 10 01 00 10 11 10 10 01 01 00 00 00 11 01 10 00 01 10 11 00 10 00 10 01 11 00 00 00 01 11 10 01 01 00 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 00 10 00 10 00 01 01 00 11 10 01 00 10 10 01 10 10 10 00 10 11 01 11 10 00",
    "00 01 01 00 01 11 01 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 10 10 11 11 11 10 01 00 11 11 01 11 00 01 10 11 11 01 00 00 01 10 11 11 10 10 00 01 11 10 11 10 00 10 10 11 10 10 11 11 11 11 00 10 00 00 11 11 01 00 11 11 01 00 11 10 00 11 10 11 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 00 01 11 11 01 10 00 10 11 11 01 10 10 10 10 00 11 01 01 00 10 00 01 01 11 00 11 10 10 10 11 01 10 00 10 11 00 10 11 10 10 01 11 00 00 00 11 01 10 00 01 10 11 00 10 00 00 01 11 00 00 00 01 11 11 01 01 01 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 10 10 00 10 01 01 01 10 10 10 01 00 10 10 01 10 10 10 00 10 11 01 10 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 10 00 11 11 11 10 01 00 11 11 01 11 00 01 10 10 11 01 00 00 01 01 11 01 10 10 01 11 10 10 11 11 00 10 10 11 10 10 11 11 11 11 01 00 00 00 11 11 10 00 11 11 01 01 01 11 00 11 10 00 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 00 01 11 11 01 10 00 10 11 11 01 10 10 10 10 00 11 01 01 00 10 00 01 01 11 00 11 10 10 10 11 01 10 00 10 11 00 10 11 10 10 01 11 00 00 00 11 01 10 00 01 10 11 00 10 00 00 01 11 00 00 00 01 11 11 01 01 01 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 10 10 00 10 01 01 01 10 10 10 01 00 10 10 01 10 10 10 00 10 11 01 10 10 00",
    "00 01 01 00 01 11 10 11 11 11 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 11 11 11 11 10 10 11 11 11 00 00 00 11 11 11 11 00 01 10 10 01 00 00 00 00 01 11 01 10 10 10 01 11 10 11 10 10 10 10 11 10 01 11 11 11 11 01 00 01 00 11 11 10 00 01 11 01 00 01 11 00 11 10 11 11 00 00 01 10 01 11 00 11 10 10 01 11 00 00 01 10 01 11 00 01 11 11 01 10 00 10 11 11 01 10 10 10 10 00 11 01 01 00 10 00 01 01 11 00 11 10 10 10 11 01 10 00 10 11 00 10 11 10 10 01 11 00 00 00 11 01 10 00 01 10 11 00 10 00 00 01 11 00 00 00 01 11 11 01 01 01 10 01 10 10 00 10 01 01 11 11 11 00 01 11 11 01 10 10 00 10 01 01 01 10 10 10 01 00 10 10 01 10 10 10 00 10 11 01 10 10 00"
]

punct_2_3 = coding.generate_puncturing_pattern(120, (2,3))

for burst_str in burst_strs:

    # Handle the burst as a byte array, each byte representing one bit
    burst = bytes(1 if c=="1" else 0 for c in burst_str.replace(" ", ""))
    burst = bytes_to_np(burst)

    # Split into fields
    sb_bits5 = burst[94:214]  # Scrambled synchronization block 1 type 5 bits
    bkn2_bits5 = burst[252:468]  # Scrambled block 2 bits

    debug.print_bits("Type 5:", sb_bits5)

    # Convert to type 4 bits
    sb_bits4 = coding.descramble(sb_bits5, coding.sb_scrambling)

    debug.print_bits("Type 4:", sb_bits4)

    # Convert to type 3 bits
    sb_bits3 = coding.deinterleave(sb_bits4, 11)

    debug.print_bits("Type 3:", sb_bits3)

    sb_depunct = coding.depuncture(coding.hard_to_soft(sb_bits3), punct_2_3)
    debug.print_softbits("Depunctured:", sb_depunct)
    sb_bits2 = coding.decode_1_4(sb_depunct)
    debug.print_bits("Type 2:", sb_bits2)

    sb_bits1 = sb_bits2[0:-16]
    debug.print_bits("Type 1 (not CRC checked):", sb_bits1)
    debug.print_bits("Received   CRC:", sb_bits2[-16:])
    debug.print_bits("Calculated CRC:", coding.crc16(sb_bits1))

    # Show some DMAC-SYNC PDU contents in SCH/S
    debug.print_bits("A/B:", sb_bits1[10:12])
    debug.print_bits("Slot number:", sb_bits1[12:14])
    debug.print_bits("Frame number:", sb_bits1[14:19])

# Speedtest
N = 10000

import time
t1 = time.time()

for i in range(N):
    sb_bits5 = burst[94:214]
    sb_bits4 = coding.descramble(sb_bits5, coding.sb_scrambling)
    sb_bits3 = coding.deinterleave(sb_bits4, 11)
    sb_depunct = coding.depuncture(coding.hard_to_soft(sb_bits3), punct_2_3)
    sb_bits2 = coding.decode_1_4(sb_depunct)
    crc = coding.crc16(sb_bits2[0:-16])

t2 = time.time()
print("Descrambled, deinterleaved and decoded %f blocks per second" % (N / (t2-t1)))
